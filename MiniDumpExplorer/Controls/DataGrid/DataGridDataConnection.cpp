#include "pch.h"
#include "DataGridDataConnection.h"

#include "DataGrid.h"
#include "DataGridColumnCollection.h"
#include "DataGridError.h"
#include "Utility/logger.h"

using namespace winrt;
using namespace Microsoft::UI::Xaml;

namespace DataGridInternal
{
    DataGridDataConnection::DataGridDataConnection(MiniDumpExplorer::implementation::DataGrid* owner)
        : owner_{owner}
    {
    }

    bool DataGridDataConnection::AllowEdit() const
    {
        return dataSource_ && !dataSource_.IsReadOnly();
    }

    bool DataGridDataConnection::AllowSort() const
    {
        return dataSource_ && !dataSource_.CanSort();
    }

    bool DataGridDataConnection::CanCancelEdit() const
    {
        return dataSource_ && !dataSource_.CanCancelEdit();
    }

    Data::ICollectionView DataGridDataConnection::CollectionView() const
    {
        if(!dataSource_)
        {
            return nullptr;
        }
        return dataSource_.CollectionView();
    }

    int32_t DataGridDataConnection::Count() const
    {
        if(!dataSource_)
        {
            return 0;
        }
        return CollectionView().Size();
    }

    bool DataGridDataConnection::DataIsPrimitive() const
    {
        return dataSource_ && dataSource_.DataIsPrimitive();
    }

    bool DataGridDataConnection::HasDataType() const
    {
        return dataSource_ && dataSource_.HasDataType();
    }

    hstring DataGridDataConnection::DataTypeTypeName() const
    {
        if(HasDataType())
        {
            return dataSource_.DataTypeTypeName();
        }

        return {};
    }

    hstring DataGridDataConnection::DataTypeName() const
    {
        if(HasDataType())
        {
            return dataSource_.DataTypeName();
        }

        return {};
    }

    Windows::Foundation::Collections::IVectorView<MiniDumpExplorer::IDataGridDataSourcePropertyInfo> DataGridDataConnection::DataProperties() const
    {
        if (dataSource_)
        {
            return dataSource_.DataProperties();
        }

        return nullptr;
    }

    hstring DataGridDataConnection::DisplayName() const
    {
        if(auto const displayName = dataSource_.try_as<Windows::Foundation::IStringable>();
            displayName)
        {
            return displayName.ToString();
        }

        return {};
    }

    bool DataGridDataConnection::HasMoreItems() const
    {
        return IsDataSourceIncremental() && incrementalItemsSource_.HasMoreItems();
    }

    bool DataGridDataConnection::IsDataSourceIncremental() const
    {
        return incrementalItemsSource_ != nullptr;
    }

    bool DataGridDataConnection::IsLoadingMoreItems() const
    {
        return loadingOperation_ != nullptr;
    }

    bool DataGridDataConnection::EndingEdit() const
    {
        return endingEdit_;
    }

    bool DataGridDataConnection::EventsWired() const
    {
        return eventsWired_;
    }

    bool DataGridDataConnection::IsAddingNew() const
    {
        return dataSource_ && dataSource_.IsAddingNew();
    }

    bool DataGridDataConnection::IsGrouping() const
    {
        if(!dataSource_)
        {
            return false;
        }
        auto const collectionView = CollectionView();
        if(!dataSource_.CanGroup())
        {
            return false;
        }
        auto const collectionGroups = collectionView.CollectionGroups();
        return collectionGroups && collectionGroups.Size() > 0;
    }

    int32_t DataGridDataConnection::NewItemPlaceholderIndex() const
    {
        if (dataSource_ && dataSource_.SupportsNewItemPlaceholder())
        {
            return Count() - 1;
        }

        return InvalidIndex;
    }

    bool DataGridDataConnection::ShouldAutoGenerateColumns() const
    {
        return owner_->AutoGenerateColumns()
            && (owner_->ColumnsInternal().AutoGeneratedColumnCount() == 0)
            && dataSource_
            && (dataSource_.HasDataProperties() || DataIsPrimitive());
    }

    // ReSharper disable once CppMemberFunctionMayBeStatic
    bool DataGridDataConnection::BeginEdit(Windows::Foundation::IInspectable const& dataItem)
    {
        if (!dataItem)
        {
            return false;
        }

        if (auto const editableDataItem = dataItem.try_as<MiniDumpExplorer::IEditableObject>();
            editableDataItem)
        {
            editableDataItem.BeginEdit();
            return true;
        }

        return true;
    }

    // ReSharper disable once CppMemberFunctionMayBeStatic
    bool DataGridDataConnection::CancelEdit(Windows::Foundation::IInspectable const& dataItem)
    {
        if (!dataItem)
        {
            return false;
        }

        if (auto const editableDataItem = dataItem.try_as<MiniDumpExplorer::IEditableObject>();
            editableDataItem)
        {
            editableDataItem.CancelEdit();
            return true;
        }

        return true;
    }

    // ReSharper disable once CppMemberFunctionMayBeStatic
    bool DataGridDataConnection::EndEdit(Windows::Foundation::IInspectable const& dataItem)
    {
        if (!dataItem)
        {
            return false;
        }

        if (auto const editableDataItem = dataItem.try_as<MiniDumpExplorer::IEditableObject>();
            editableDataItem)
        {
            editableDataItem.EndEdit();
            return true;
        }

        return true;
    }

    Windows::Foundation::IInspectable DataGridDataConnection::GetDataItem(int32_t const index) const
    {
        if(index > Count() || index < 0)
        {
            return nullptr;
        }

        return CollectionView().GetAt(static_cast<uint32_t>(index));
    }

    bool DataGridDataConnection::GetPropertyIsReadOnly(std::wstring const& propertyName) const
    {
        if (dataSource_)
        {
            return dataSource_.GetPropertyIsReadOnly(propertyName);
        }
        return !AllowEdit();
    }

    int32_t DataGridDataConnection::IndexOf(Windows::Foundation::IInspectable const& dataItem) const
    {
        if(uint32_t index; CollectionView().IndexOf(dataItem, index))
        {
            return static_cast<int32_t>(index);
        }

        return InvalidIndex;
    }

    void DataGridDataConnection::LoadMoreItems(int32_t const count)
    {
        assert(!loadingOperation_);

        loadingOperation_ = incrementalItemsSource_.LoadMoreItemsAsync(static_cast<uint32_t>(count));

        if (loadingOperation_)
        {
            loadingOperation_.Completed({this, &DataGridDataConnection::OnLoadingOperationCompleted});
        }
    }

    hstring DataGridDataConnection::GetPropertyDisplayName(hstring const& propertyPath) const
    {
        if (dataSource_)
        {
            return dataSource_.GetPropertyDisplayName(propertyPath);
        }

        return {};
    }

    MiniDumpExplorer::IDataGridDataSource DataGridDataConnection::CreateView(Windows::Foundation::IInspectable const& source)
    {
        assert(!source);

        auto dataSource = source.try_as<MiniDumpExplorer::IDataGridDataSource>();
        if (auto const collectionViewFactory = source.try_as<MiniDumpExplorer::IDataGridDataSourceFactory>();
            !collectionViewFactory)
        {
            // If the source is a collection view factory, give it a chance to produce a custom collection view.
            dataSource = collectionViewFactory.CreateView();

            // Intentionally not catching potential exception thrown by IDataGridDataSourceFactory.CreateView().
        }

        return dataSource;
    }

    void DataGridDataConnection::ClearDataProperties() const
    {
        if(dataSource_)
        {
            dataSource_.ClearDataProperties();
        }
    }

    void DataGridDataConnection::MoveCurrentTo(Windows::Foundation::IInspectable const& item, int32_t const backupSlot, int32_t const columnIndex, DataGridSelectionAction const action, bool const scrollIntoView)
    {
        if (dataSource_)
        {
            auto const collectionView = CollectionView();
            expectingCurrentChanged_ = true;
            columnForCurrentChanged_ = columnIndex;
            itemToSelectOnCurrentChanged_ = item;
            selectionActionForCurrentChanged_ = action;
            scrollForCurrentChanged_ = scrollIntoView;
            backupSlotForCurrentChanged_ = backupSlot;

            auto const itemIsCollectionViewGroup = static_cast<bool>(item.try_as<Data::ICollectionViewGroup>());

            [[maybe_unused]] auto const result = collectionView.MoveCurrentTo((itemIsCollectionViewGroup || IndexOf(item) == NewItemPlaceholderIndex()) ? nullptr : item);

            expectingCurrentChanged_ = false;
        }
    }

    void DataGridDataConnection::UnWireEvents(Windows::Foundation::IInspectable const& value)
    {
        if (auto const notifyingDataSource1 = value.try_as<Interop::INotifyCollectionChanged>();
            notifyingDataSource1 && weakCollectionChangedListener_)
        {
            weakCollectionChangedListener_->Detach();
            weakCollectionChangedListener_.release();
        }

        if (auto const notifyingDataSource2 = value.try_as<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>();
            notifyingDataSource2 && weakVectorChangedListener_)
        {
            weakVectorChangedListener_->Detach();
            weakVectorChangedListener_.release();
        }
        if (dataSource_)
        {
            if (weakCurrentChangedListener_)
            {
                weakCurrentChangedListener_->Detach();
                weakCurrentChangedListener_.release();
            }

            if (weakCurrentChangingListener_)
            {
                weakCurrentChangingListener_->Detach();
                weakCurrentChangingListener_.release();
            }
        }

        eventsWired_ = false;
    }

    void DataGridDataConnection::WireEvents(Windows::Foundation::IInspectable const& value)
    {
        if (auto const notifyingDataSource1 = value.try_as<Interop::INotifyCollectionChanged>();
            notifyingDataSource1)
        {
            weakCollectionChangedListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::IInspectable, Interop::NotifyCollectionChangedEventArgs>>(*owner_);
            weakCollectionChangedListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& source, auto const& eventArgs) { NotifyingDataSourceCollectionChanged(source, eventArgs); });
            auto const event = notifyingDataSource1.CollectionChanged([this](auto const& sender, auto const& e) {weakCollectionChangedListener_->OnEvent(sender, e); });
            weakCollectionChangedListener_->OnDetachAction([notify = static_cast<Interop::INotifyCollectionChanged>(notifyingDataSource1), event](auto const&){ notify.CollectionChanged(event); } );
        }
        else if (auto const notifyingDataSource2 = value.try_as<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>();
                notifyingDataSource2)
        {
            weakVectorChangedListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>, Windows::Foundation::Collections::IVectorChangedEventArgs>>(*owner_);
            weakVectorChangedListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& source, auto const& eventArgs) { NotifyingDataSourceVectorChanged(source, eventArgs); });
            auto const event = notifyingDataSource2.VectorChanged([this](auto const& sender, auto const& e) {weakVectorChangedListener_->OnEvent(sender, e); });
            weakVectorChangedListener_->OnDetachAction([notify = static_cast<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>(notifyingDataSource2), event](auto const&){ notify.VectorChanged(event); } );
        }

        if (dataSource_)
        {
            // A local variable must be used in the lambda expression or the CollectionView will leak
            auto const collectionView = CollectionView();

            weakVectorChangedListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>, Windows::Foundation::Collections::IVectorChangedEventArgs>>(*owner_);
            weakVectorChangedListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& source, auto const& eventArgs) { NotifyingDataSourceVectorChanged(source, eventArgs); });
            {
                auto const event = collectionView.VectorChanged([this](auto const& sender, auto const& e) {weakVectorChangedListener_->OnEvent(sender, e); });
                weakVectorChangedListener_->OnDetachAction([notify = static_cast<Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable>>(collectionView), event](auto const&){ notify.VectorChanged(event); } );
            }

            weakCurrentChangedListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::IInspectable, Windows::Foundation::IInspectable>>(*owner_);
            weakCurrentChangedListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& source, auto const& eventArgs) { OnCollectionViewCurrentChanged(source, eventArgs); });
            {
                auto const event = collectionView.CurrentChanged([this](auto const& sender, auto const& e) { weakCurrentChangedListener_->OnEvent(sender, e); });
                weakCurrentChangedListener_->OnDetachAction([collectionView, event](auto const&){ collectionView.CurrentChanged(event); } );
            }

            weakCurrentChangingListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::IInspectable, Data::CurrentChangingEventArgs>>(*owner_);
            weakCurrentChangingListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& sender, auto const& e) { OnCollectionViewCurrentChanging(sender, e); });
            {
                auto const event = collectionView.CurrentChanging([this](auto const& sender, auto const& e) { weakCurrentChangingListener_->OnEvent(sender, e); });
                weakCurrentChangingListener_->OnDetachAction([collectionView, event](auto const&){ collectionView.CurrentChanging(event); } );
            }
        }

        eventsWired_ = true;
    }

    void DataGridDataConnection::OnCollectionViewCurrentChanged([[maybe_unused]] Windows::Foundation::IInspectable const& sender, [[maybe_unused]] Windows::Foundation::IInspectable const& e)
    {
        if (expectingCurrentChanged_)
        {
            // Committing Edit could cause our item to move to a group that no longer exists.  In
            // this case, we need to update the item.
            if (auto const collectionViewGroup = itemToSelectOnCurrentChanged_.try_as<Data::ICollectionViewGroup>();
                collectionViewGroup)
            {
                if (auto const groupInfo = owner_->RowGroupInfoFromCollectionViewGroup(collectionViewGroup);
                    groupInfo)
                {
                    // Move to the next slot if the target slot isn't visible
                    if (!owner_->IsSlotVisible(backupSlotForCurrentChanged_))
                    {
                        backupSlotForCurrentChanged_ = owner_->GetNextVisibleSlot(backupSlotForCurrentChanged_);
                    }

                    // Move to the next best slot if we've moved past all the slots.  This could happen if multiple
                    // groups were removed.
                    if (backupSlotForCurrentChanged_ >= owner_->SlotCount())
                    {
                        backupSlotForCurrentChanged_ = owner_->GetPreviousVisibleSlot(owner_->SlotCount());
                    }

                    // Update the itemToSelect
                    auto newCurrentPosition = InvalidIndex;
                    itemToSelectOnCurrentChanged_ = owner_->ItemFromSlot(backupSlotForCurrentChanged_, newCurrentPosition);
                }
            }

            owner_->ProcessSelectionAndCurrency(
                columnForCurrentChanged_,
                itemToSelectOnCurrentChanged_,
                backupSlotForCurrentChanged_,
                selectionActionForCurrentChanged_,
                scrollForCurrentChanged_);
        }
        else if (dataSource_)
        {
            auto const collectionView = CollectionView();
            owner_->UpdateStateOnCurrentChanged(collectionView.CurrentItem(), collectionView.CurrentPosition());
        }
    }

    void DataGridDataConnection::OnCollectionViewCurrentChanging([[maybe_unused]] Windows::Foundation::IInspectable const& sender, Data::CurrentChangingEventArgs const& e) const
    {
        if (owner_->NoCurrentCellChangeCount() == 0 &&
            !expectingCurrentChanged_ &&
            !EndingEdit() &&
            !owner_->CommitEdit())
        {
            // If CommitEdit failed, then the user has most likely input invalid data.
            // Cancel the current change if possible, otherwise abort the edit.
            if (e.IsCancelable())
            {
                e.Cancel(true);
            }
            else
            {
                owner_->CancelEdit(MiniDumpExplorer::DataGridEditingUnit::Row, false);
            }
        }
    }

    void DataGridDataConnection::NotifyingDataSourceCollectionChanged([[maybe_unused]] Windows::Foundation::IInspectable const& sender, Interop::NotifyCollectionChangedEventArgs const& e) const
    {
        try
        {
            if (owner_->LoadingOrUnloadingRow())
            {
                throw DataGridError::DataGrid::CannotChangeItemsWhenLoadingRows();
            }

            switch (e.Action())
            {
            case Interop::NotifyCollectionChangedAction::Add:
                assert(e.NewItems());
                assert(ShouldAutoGenerateColumns() || IsGrouping() || e.NewItems().Size() == 1);
                NotifyingDataSourceAdd(e.NewStartingIndex());
                break;

            case Interop::NotifyCollectionChangedAction::Remove:
            {
                auto const removedItems = e.OldItems();
                if (!removedItems || e.OldStartingIndex() < 0)
                {
                    return;
                }

                if (!IsGrouping())
                {
                    // If we're grouping then we handle this through the CollectionViewGroup notifications.
                    // Remove is a single item operation.
                    for(uint32_t index = 0; index < removedItems.Size(); ++index)
                    {
                        auto const item = removedItems.GetAt(index);
                        assert(item);
                        owner_->RemoveRowAt(e.OldStartingIndex(), item);
                    }
                }
                break;
            }

            case Interop::NotifyCollectionChangedAction::Replace:
                throw DataGridError::DataGrid::NotifyCollectionChangedActionReplaceNotSupported();

            case Interop::NotifyCollectionChangedAction::Reset:
                NotifyingDataSourceReset();
                break;

            default:
                break;
            }
        }
        catch(...)
        {
            logger::HandleUnknownException();
        }
    }

    void DataGridDataConnection::NotifyingDataSourceVectorChanged(Windows::Foundation::Collections::IObservableVector<Windows::Foundation::IInspectable> const& sender, Windows::Foundation::Collections::IVectorChangedEventArgs const& e) const
    {
        try
        {
            if (owner_->LoadingOrUnloadingRow())
            {
                throw DataGridError::DataGrid::CannotChangeItemsWhenLoadingRows();
            }

            auto const index = e.Index();

            switch (e.CollectionChange())
            {
            case Windows::Foundation::Collections::CollectionChange::ItemChanged:
                throw DataGridError::DataGrid::CollectionChangeItemChangedNotSupported();

            case Windows::Foundation::Collections::CollectionChange::ItemInserted:
                NotifyingDataSourceAdd(index);
                break;

            case Windows::Foundation::Collections::CollectionChange::ItemRemoved:
                if (!IsGrouping())
                {
                    // If we're grouping then we handle this through the CollectionViewGroup notifications.
                    // Remove is a single item operation.
                    owner_->RemoveRowAt(index, sender.GetAt(index));
                }

                break;

            case Windows::Foundation::Collections::CollectionChange::Reset:
                NotifyingDataSourceReset();
                break;
            }
        }
        catch(...)
        {
            logger::HandleUnknownException();
        }
    }

    void DataGridDataConnection::NotifyingDataSourceAdd(int32_t const index) const
    {
        if (ShouldAutoGenerateColumns())
        {
            // The columns are also affected (not just rows) in this case, so reset everything.
            owner_->InitializeElements(false /*recycleRows*/);
        }
        else if (!IsGrouping())
        {
            // If we're grouping then we handle this through the CollectionViewGroup notifications.
            // Add is a single item operation.
            owner_->InsertRowAt(index);
        }
    }

    void DataGridDataConnection::NotifyingDataSourceReset() const
    {
        // Did the data type change during the reset?  If not, we can recycle
        // the existing rows instead of having to clear them all.  We still need to clear our cached
        // values for DataType and DataProperties, though, because the collection has been reset.
        if (dataSource_.NotifyingDataSourceReset())
        {
            ClearDataProperties();
            owner_->InitializeElements(false /*recycleRows*/);
        }
        else
        {
            owner_->InitializeElements(!ShouldAutoGenerateColumns() /*recycleRows*/);
        }
    }

    void DataGridDataConnection::NotifyingIncrementalItemsSource([[maybe_unused]] Windows::Foundation::IInspectable const& sender, Data::PropertyChangedEventArgs const& e) const
    {
        if (e.PropertyName() == L"HasMoreItems")
        {
            owner_->LoadMoreDataFromIncrementalItemsSource();
        }
    }

    void DataGridDataConnection::OnLoadingOperationCompleted([[maybe_unused]] Windows::Foundation::IAsyncOperation<Data::LoadMoreItemsResult> const& asyncInfo, Windows::Foundation::AsyncStatus const& asyncStatus)
    {
        if (asyncStatus != Windows::Foundation::AsyncStatus::Started)
        {
            loadingOperation_ = nullptr;
        }
    }

    void DataGridDataConnection::UpdateDataProperties() const
    {
        dataSource_.UpdateDataProperties();
    }

    void DataGridDataConnection::UpdateIncrementalItemsSource()
    {
        if (weakIncrementalItemsSourcePropertyChangedListener_)
        {
            weakIncrementalItemsSourcePropertyChangedListener_->Detach();
            weakIncrementalItemsSourcePropertyChangedListener_.release();
        }

        // Determine if incremental loading should be used
        if (auto const incrementalDataSource = dataSource_.try_as<Data::ISupportIncrementalLoading>();
            incrementalDataSource)
        {  // NOLINT(bugprone-branch-clone)
            incrementalItemsSource_ = incrementalDataSource;
        }
        else if (auto const incrementalItemsSource = owner_->ItemsSource().try_as<Data::ISupportIncrementalLoading>();
            incrementalItemsSource)
        {
            incrementalItemsSource_ = incrementalItemsSource;
        }
        else
        {
            incrementalItemsSource_ = nullptr;
        }

        if (incrementalItemsSource_)
        {
            if(auto const notifyPropertyChanged = incrementalItemsSource_.try_as<Data::INotifyPropertyChanged>())
            {
                weakIncrementalItemsSourcePropertyChangedListener_ = std::make_unique<Utility::WeakEventListener<MiniDumpExplorer::DataGrid, Windows::Foundation::IInspectable, Data::PropertyChangedEventArgs>>(*owner_);
                weakIncrementalItemsSourcePropertyChangedListener_->OnEventAction([this]([[maybe_unused]] auto const& instance, auto const& source, auto const& eventArgs) { NotifyingIncrementalItemsSource(source, eventArgs); });
                auto const event = notifyPropertyChanged.PropertyChanged([this](auto const& sender, auto const& e) {weakIncrementalItemsSourcePropertyChangedListener_->OnEvent(sender, e); });
                weakIncrementalItemsSourcePropertyChangedListener_->OnDetachAction([notify = static_cast<Data::INotifyPropertyChanged>(notifyPropertyChanged), event](auto const&){ notify.PropertyChanged(event); } );
            }
        }

        if (loadingOperation_)
        {
            loadingOperation_.Cancel();
            loadingOperation_ = nullptr;
        }
    }
}
